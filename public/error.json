[
  {
    "title": "400",
    "reason": "클라이언트의 요청이 서버까지 전송되었지만, 요청 구문이나 쿼리 스트링, 헤더 등 형식이 HTTP 사양이나 해당 API 스펙에 맞지 않아 서버가 요청을 해석하지 못할 때 발생합니다. 예를 들어 잘못된 JSON 포맷, 누락된 필수 파라미터, 부적절한 헤더 등이 원인이 됩니다.",
    "solve": "요청 바디와 쿼리스트링, 헤더 등을 다시 확인하여 스펙에 맞추세요. JSON 파싱이 필요한 경우 유효성 검사를 추가하고, 필수 필드를 모두 채우도록 클라이언트 로직을 수정합니다."
  },
  {
    "title": "401",
    "reason": "인증이 필요한 리소스에 대해 클라이언트가 유효한 인증 자격증명(예: 토큰, 쿠키, 세션 등)을 제공하지 않았거나, 제공된 자격증명이 만료 혹은 무효화되어 인증이 실패했을 때 발생합니다.",
    "solve": "유저가 로그인 상태인지 확인하고, 올바른 인증 토큰을 요청 헤더(Authorization)에 포함하도록 클라이언트와 서버를 수정하세요. 토큰 만료 시 재로그인 혹은 토큰 갱신 로직을 구현합니다."
  },
  {
    "title": "402",
    "reason": "결제가 필요한 리소스에 대해 클라이언트가 결제 단계(예: 유료 API 호출, 구독 모델 등)를 완료하지 않아 접근이 차단될 때 사용하도록 예약된 코드입니다. 실제 HTTP 사양에서 널리 사용되지는 않습니다.",
    "solve": "서비스가 유료 모델이라면 클라이언트에게 결제 페이지로 리다이렉트하거나 결제 정보를 요청해 처리하세요. 불사용 시에는 403으로 대체할 수 있습니다."
  },
  {
    "title": "403",
    "reason": "클라이언트가 올바른 인증 정보를 제공했더라도 해당 리소스에 대한 권한(역할 기반 접근 제어, ACL 등)이 없을 때 발생합니다. 예를 들어 일반 사용자가 관리자 전용 API를 호출하는 경우가 이에 해당합니다.",
    "solve": "사용자 권한 체계를 점검하고, 필요한 권한을 부여하거나 권한 검증 로직을 수정하세요. 클라이언트에 권한 부족 메시지를 명확히 전달합니다."
  },
  {
    "title": "404",
    "reason": "클라이언트의 요청이 서버에 도달했지만, 해당 URL 경로 또는 엔드포인트에 매핑된 리소스가 존재하지 않을 때 발생합니다. 오타, 잘못된 라우팅 설정, 삭제된 페이지나 미구현된 API 등이 원인이 될 수 있습니다.",
    "solve": "요청 경로를 다시 확인하고, 서버 라우터 설정이 정확한지 검토하세요. 없는 리소스라면 API 문서에 올바른 경로를 안내하거나 엔드포인트를 생성합니다."
  },
  {
    "title": "405",
    "reason": "클라이언트가 지정된 URL에서 지원하지 않는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용했을 때 발생합니다. 예를 들어 GET 전용 엔드포인트에 POST 요청을 보낸 경우입니다.",
    "solve": "서버에 구현된 메서드 목록과 클라이언트 요청 방식이 일치하도록 맞추세요. 필요 시 서버에 해당 메서드를 추가 구현하거나 클라이언트 요청 방식을 변경합니다."
  },
  {
    "title": "406",
    "reason": "클라이언트가 Accept 헤더에 특정 미디어 타입(예: application/json, text/html 등)을 명시했으나, 서버가 그 타입으로 응답할 수 없을 때 발생합니다.",
    "solve": "서버에서 지원 가능한 콘텐츠 타입을 클라이언트에 안내하고, Accept 헤더 값을 조정하도록 유도하세요. 추가 포맷(JSON, XML 등)을 구현할 수도 있습니다."
  },
  {
    "title": "407",
    "reason": "클라이언트가 프록시 서버를 통해 요청할 때 Proxy-Authorization 헤더에 유효한 인증 정보를 포함하지 않아 프록시 인증이 실패했을 때 발생합니다.",
    "solve": "클라이언트 설정에서 Proxy-Authorization 헤더를 정확히 추가하도록 수정하고, 프록시 서버의 인증 로직을 확인하세요."
  },
  {
    "title": "408",
    "reason": "클라이언트가 지정된 시간(타임아웃) 내에 서버로 완전한 요청을 전송하지 못해 서버가 연결을 종료했을 때 발생합니다.",
    "solve": "클라이언트의 요청 타임아웃 설정을 늘리거나, 네트워크 상태를 개선하세요. 서버 측에서는 긴 처리 작업에 대해 비동기 처리나 Keep-Alive 설정을 검토합니다."
  },
  {
    "title": "409",
    "reason": "클라이언트의 요청이 서버에 저장된 리소스 상태와 충돌(conflict)하여 처리할 수 없을 때 발생합니다. 예를 들어 동시 수정으로 인한 버전 불일치나 중복된 데이터 생성 시도 등이 있습니다.",
    "solve": "조건부 요청(If-Match 헤더 등)을 도입해 버전 관리 로직을 구현하거나, 클라이언트가 보낸 데이터와 서버 상태를 비교해 충돌을 해소하도록 합니다."
  },
  {
    "title": "410",
    "reason": "클라이언트가 요청한 리소스가 과거에는 존재했으나 의도적으로 영구 삭제되어 더 이상 제공되지 않을 때 발생합니다. 복구되지 않는 삭제 상태를 명확히 알릴 때 사용합니다.",
    "solve": "삭제된 리소스임을 클라이언트에 알리고, 대체 리소스 경로를 안내하거나 API 문서에서 제거 사실을 공지하세요."
  },
  {
    "title": "411",
    "reason": "클라이언트가 HTTP 메시지 바디를 포함하는 요청(POST, PUT 등) 시 필수 헤더인 Content-Length를 제공하지 않아 서버가 바디 길이를 알 수 없을 때 발생합니다.",
    "solve": "클라이언트가 요청 바디 길이를 측정해 Content-Length 헤더를 포함하도록 수정하고, 서버에서 청크 인코딩(Transfer-Encoding: chunked)을 지원하도록 설정할 수 있습니다."
  },
  {
    "title": "412",
    "reason": "클라이언트가 If-Unmodified-Since, If-Match 등의 조건부 요청 헤더를 사용했으나, 서버의 리소스가 해당 조건(최신 버전, 특정 ETag와 일치 등)을 만족하지 않을 때 발생합니다.",
    "solve": "조건부 헤더 값이 최신인지 확인하고, 필요 시 클라이언트에 최신 ETag나 수정 일시를 전달해 재요청하도록 합니다."
  },
  {
    "title": "413",
    "reason": "클라이언트가 전송한 요청 본문(payload)의 크기가 서버에서 허용한 최대치를 초과하여 처리할 수 없을 때 발생합니다. 일반적으로 대용량 파일 업로드 시 나타납니다.",
    "solve": "클라이언트에서 전송 데이터 크기를 줄이거나, 서버 설정에서 최대 허용 크기를 늘립니다. 대용량 파일은 청크 업로드로 분할하세요."
  },
  {
    "title": "414",
    "reason": "클라이언트의 요청 URI(또는 쿼리스트링 포함)가 서버 설정에서 허용하는 최대 길이를 초과할 때 발생합니다.",
    "solve": "쿼리스트링을 줄이거나, POST 방식으로 파라미터를 전송하도록 변경하세요. 서버 측 설정에서 최대 URI 길이 제한을 조정할 수도 있습니다."
  },
  {
    "title": "415",
    "reason": "클라이언트가 요청 헤더(Content-Type)에 명시한 미디어 타입을 서버가 지원하지 않을 때 발생합니다. 예를 들어 서버가 JSON만 처리하는데 text/xml로 요청이 왔을 때입니다.",
    "solve": "지원 가능한 Content-Type 목록을 클라이언트에 안내하고, 요청 헤더를 올바른 타입(e.g., application/json)으로 수정하도록 합니다."
  },
  {
    "title": "416",
    "reason": "클라이언트가 Range 헤더를 이용해 요청한 바이트 범위가 실제 리소스 크기 범위를 벗어나거나, 잘못된 형식일 때 발생합니다.",
    "solve": "클라이언트가 요청한 Range 값을 검증해 유효 범위 내에서 재요청하도록 수정하거나, 서버에서 범위를 조정해 응답합니다."
  },
  {
    "title": "417",
    "reason": "클라이언트가 Expect: 100-continue 등과 같이 특정 기대값을 Expect 헤더에 포함했으나, 서버가 이를 지원하지 않아 요청이 거부될 때 발생합니다.",
    "solve": "클라이언트에서 Expect 헤더를 제거하거나, 서버가 해당 기대값을 지원하도록 구현을 확장합니다."
  },
  {
    "title": "418",
    "reason": "RFC 2324 만우절 농담용 코드로, 서버가 'I'm a teapot' 상태임을 나타냅니다. 실제 운영 환경에서는 사용되지 않는 유머용 상태 코드입니다.",
    "solve": "실제 서비스 로직에서는 사용되지 않으므로 무시하거나 제거합니다."
  },
  {
    "title": "421",
    "reason": "클라이언트가 Host 헤더 등에 지정한 대상 서버 이름이 잘못되어 요청이 부적절한 서버로 전달되었거나, 라우팅 매핑에 실패했을 때 발생합니다.",
    "solve": "클라이언트가 올바른 호스트 이름을 사용하도록 수정하고, 서버 사이드 라우팅 설정을 검토하세요."
  },
  {
    "title": "422",
    "reason": "요청 문법은 올바르지만, 도메인 로직이나 비즈니스 규칙(예: 중복 검사, 데이터 유효성) 위반으로 서버가 엔티티를 처리할 수 없을 때 발생합니다.",
    "solve": "서버의 비즈니스 검증 로직을 확인하고, 클라이언트가 전송하는 데이터가 유효한 비즈니스 규칙을 따르도록 수정하세요."
  },
  {
    "title": "423",
    "reason": "요청된 리소스가 잠금(lock) 상태여서 접근할 수 없을 때 발생합니다. 주로 협업 편집, 분산 락 시나리오에서 사용됩니다.",
    "solve": "락을 해제하거나, 클라이언트에 락 상태 정보를 전달해 대기 또는 재시도 로직을 구현합니다."
  },
  {
    "title": "424",
    "reason": "이전에 수행된 의존성 요청이 실패하여 현재 요청을 처리할 수 없을 때 발생합니다. 멀티 스텝 트랜잭션이나 배치 작업 중 의존성 오류 시 주로 사용됩니다.",
    "solve": "의존성 요청들의 성공 여부를 확인하고, 순차 처리 로직이나 트랜잭션 롤백 방식을 검토해 오류 전파를 제어하세요."
  },
  {
    "title": "425",
    "reason": "클라이언트의 요청이 보안 취약점(예: 재생 공격) 방지를 위해 '너무 이른(Too Early)' 단계로 판단되어 서버가 거부할 때 사용됩니다.",
    "solve": "재생 공격 방지 헤더나 nonce 전략을 도입해 요청을 안전하게 하고, 서버에서 425 지원 여부를 결정하세요."
  },
  {
    "title": "426",
    "reason": "클라이언트가 현재 프로토콜보다 상위 프로토콜(예: HTTP/2, TLS 업그레이드) 사용을 요구받을 때 발생합니다. Upgrade 헤더를 통해 프로토콜 전환을 요청합니다.",
    "solve": "Upgrade 헤더를 사용해 클라이언트에게 업그레이드를 요청하거나, 서버에서 하위 호환 모드를 제공하도록 설정하세요."
  },
  {
    "title": "428",
    "reason": "사전 조건(If-Match, If-Unmodified-Since 등)이 필요한 요청에서 클라이언트가 해당 조건부 헤더를 포함하지 않아 요청이 거부될 때 발생합니다.",
    "solve": "클라이언트가 전제 조건 헤더를 포함하도록 문서화하고, 헤더 값이 충돌 없이 갱신되었는지 검증 로직을 구현하세요."
  },
  {
    "title": "429",
    "reason": "클라이언트가 짧은 시간 내에 과도한 요청을 전송하여 서버가 과부하 방지 및 서비스 안정성을 위해 요청을 거부할 때 발생합니다.",
    "solve": "Rate limiting 정책을 클라이언트에 안내하고, Retry-After 헤더 로직을 구현하세요. 클라이언트에도 지수 백오프를 적용하도록 합니다."
  },
  {
    "title": "431",
    "reason": "클라이언트의 요청 헤더 필드(이름, 값) 총합이 서버에서 허용하는 최대 크기를 초과할 때 발생합니다.",
    "solve": "불필요한 쿠키나 긴 헤더 값을 제거하고, 서버 설정에서 최대 헤더 크기 제한을 조정하세요."
  },
  {
    "title": "451",
    "reason": "법적 사유(검열, 저작권 보호, 법원 명령 등)로 인해 요청한 리소스를 제공할 수 없을 때 발생합니다.",
    "solve": "법적 제약 사유를 사용자에게 안내하고, 대체 가능한 리소스나 해결 방법을 문서화해 제공합니다."
  },
  {
    "title": "500",
    "reason": "서버 내부에서 예기치 않은 예외나 로직 오류, 시스템 장애 등이 발생하여 요청을 정상 처리할 수 없을 때 발생합니다.",
    "solve": "서버 로그를 확인해 스택 트레이스 및 오류 원인을 파악하고, 예외 처리를 강화해 클라이언트에 명확한 에러 메시지를 반환하도록 개선하세요."
  },
  {
    "title": "501",
    "reason": "서버가 클라이언트가 요청한 HTTP 메서드나 기능(엔드포인트, 확장 등)을 지원하지 않을 때 발생합니다.",
    "solve": "지원되지 않는 기능을 서버에 추가 구현하거나, 클라이언트에서 다른 대체 API를 호출하도록 수정하세요."
  },
  {
    "title": "502",
    "reason": "서버가 게이트웨이 또는 프록시로 동작하며 상위(업스트림) 서버로부터 잘못된 응답을 받아 클라이언트 요청을 처리하지 못할 때 발생합니다.",
    "solve": "업스트림 서버 상태를 점검하고, 프록시 설정(타임아웃, 헤더 전달 등)을 조정하세요. 장애가 있는 서버를 제거하거나 로드밸런서를 재구성합니다."
  },
  {
    "title": "503",
    "reason": "서버가 일시적인 과부하나 유지보수 등의 이유로 요청을 처리할 수 없을 때 발생합니다.",
    "solve": "서버 자원을 확장하거나, 유지보수 페이지를 제공하고 Retry-After 헤더를 설정하세요. Auto-scaling 정책을 도입해 과부하를 방지합니다."
  },
  {
    "title": "504",
    "reason": "서버가 게이트웨이 또는 프록시로 동작하며 상위 서버로부터 지정된 시간 내에 응답을 받지 못해 타임아웃이 발생할 때 발생합니다.",
    "solve": "업스트림 서버의 성능과 네트워크 상태를 점검하고, 프록시 타임아웃 설정을 늘리거나 비동기 처리를 고려하세요."
  },
  {
    "title": "505",
    "reason": "클라이언트가 요청에 지정한 HTTP 버전(예: HTTP/1.0, HTTP/2)을 서버가 지원하지 않을 때 발생합니다.",
    "solve": "지원 가능한 HTTP 버전을 클라이언트에 안내하고, 요청을 해당 버전으로 변경하도록 유도하세요."
  },
  {
    "title": "506",
    "reason": "서버 내부에서 콘텐츠 협상 과정 중 순환 참조(loop)를 감지하여 협상을 완료하지 못할 때 발생합니다.",
    "solve": "컨텐츠 협상 로직을 재검토하고, 순환 참조를 제거하거나 캐싱을 도입해 무한 루프를 방지하세요."
  },
  {
    "title": "507",
    "reason": "서버가 요청 처리를 위한 충분한 저장 공간이 부족하여 더 이상 공간을 할당할 수 없을 때 발생합니다.",
    "solve": "디스크 사용량을 모니터링하고 불필요한 파일을 삭제하거나, 스토리지를 확장하세요. 대용량 데이터는 아카이빙 전략을 도입합니다."
  },
  {
    "title": "508",
    "reason": "서버가 내부 루프(무한 재귀 호출, 순환 참조) 상황을 감지하여 처리를 중단할 때 발생합니다.",
    "solve": "재귀 호출이나 순환 참조 구조를 점검해 종료 조건을 명확히 정의하고, 타임아웃 또는 최대 반복 횟수를 설정하세요."
  },
  {
    "title": "510",
    "reason": "클라이언트가 요청한 확장(Extensions) 요구 사항이 서버에 설치되거나 활성화되지 않아 처리가 거부될 때 발생합니다.",
    "solve": "필요한 확장 모듈이나 프로토콜 기능을 서버에 설치 또는 활성화하고, 클라이언트에게 요구 사항을 문서화하세요."
  },
  {
    "title": "511",
    "reason": "네트워크 접속(예: captive portal 인증)이 필요한 리소스에 대해 클라이언트가 인증을 완료하지 않아 접근이 차단될 때 발생합니다.",
    "solve": "사용자가 인증 페이지로 리다이렉트되도록 안내하고, 네트워크 인증 후 요청을 재시도하도록 구현하세요."
  },
  {
    "title": "100",
    "reason": "클라이언트의 초기 요청 헤더를 서버가 수신했고, 요청 본문을 계속 전송해도 된다는 뜻입니다. 예를 들어 대용량 업로드 전 미리 헤더만 보낼 때 사용합니다.",
    "solve": "클라이언트는 본문 전송을 계속 진행하거나, 이미 보낸 경우 이 응답을 무시하면 됩니다."
  },
  {
    "title": "101",
    "reason": "클라이언트가 Upgrade 헤더로 요청한 프로토콜 전환을 서버가 수락했음을 뜻합니다. 예를 들어 HTTP/1.1에서 WebSocket으로 전환할 때 사용됩니다.",
    "solve": "클라이언트는 새 프로토콜 규약에 따라 통신을 이어가야 합니다."
  },
  {
    "title": "102",
    "reason": "WebDAV 확장 코드로, 서버가 요청을 수신하고 처리 중이지만 아직 완료할 수 없음을 나타냅니다. 주로 다단계 처리 작업에서 사용됩니다.",
    "solve": "클라이언트는 처리가 완료될 때까지 기다리거나 일정 간격으로 상태를 폴링하세요."
  },
  {
    "title": "103",
    "reason": "초기 힌트(Early Hints)를 제공해 클라이언트가 미리 리소스를 프리로드할 수 있게 하는 데 쓰입니다. 본 응답 후 최종 상태(200 등)가 뒤따릅니다.",
    "solve": "클라이언트는 Link 헤더에 명시된 리소스를 우선적으로 로드해 페이지 성능을 최적화할 수 있습니다."
  },
  {
    "title": "200",
    "reason": "요청이 성공적으로 처리되었음을 나타냅니다. 일반적인 성공 응답으로, GET/POST/PUT/DELETE 등 모든 메서드에 대해 사용됩니다.",
    "solve": "클라이언트는 응답 본문을 파싱해 UI에 반영하거나 다음 로직으로 이동합니다."
  },
  {
    "title": "201",
    "reason": "요청이 성공적으로 처리되었으며, 서버가 새로운 리소스를 생성했음을 나타냅니다. Location 헤더에 생성된 리소스의 URI가 제공됩니다.",
    "solve": "클라이언트는 Location 헤더의 URL을 참조해 새 리소스를 조회하거나, 생성된 아이디를 저장합니다."
  },
  {
    "title": "202",
    "reason": "요청을 수신하고 유효성을 검사했으나 아직 처리되지 않았음을 나타냅니다. 비동기 작업 큐에 넣는 식의 처리에 적합합니다.",
    "solve": "클라이언트는 처리 완료 상태를 확인할 수 있는 별도 엔드포인트를 폴링하거나, 웹훅 콜백을 기다립니다."
  },
  {
    "title": "203",
    "reason": "서버가 클라이언트에 제공하는 메타정보가 원 서버가 아닌 제3자 출처에서 오는 것을 나타냅니다. 주로 프록시 캐시나 중개 서버에서 사용합니다.",
    "solve": "클라이언트는 이 정보가 신뢰할 수 있는지 확인 후 사용하거나, 필요 시 원 서버에 직접 요청합니다."
  },
  {
    "title": "204",
    "reason": "요청은 성공했으나 응답할 본문이 없음을 나타냅니다. 예를 들어 DELETE 요청에서 삭제 후 본문이 필요 없을 때 사용합니다.",
    "solve": "클라이언트는 화면 갱신이나 후속 로직 실행 시 본문 처리를 건너뛰고 상태만 업데이트합니다."
  },
  {
    "title": "205",
    "reason": "요청이 성공했으며, 클라이언트 측 문서 뷰어(폼, 다이얼로그 등)를 리셋해야 함을 지시합니다.",
    "solve": "클라이언트는 입력 폼 등을 초기 상태로 리셋해 사용자가 새로 입력할 수 있게 합니다."
  },
  {
    "title": "206",
    "reason": "클라이언트가 Range 헤더로 부분 요청을 보냈고, 서버가 요청 범위 일부를 성공적으로 제공했음을 나타냅니다.",
    "solve": "클라이언트는 응답 바디를 합쳐 전체 리소스를 구성하거나, 스트리밍 플레이어 등에 바로 전달합니다."
  },
  {
    "title": "207",
    "reason": "WebDAV 확장으로, 여러 리소스에 대한 상태를 한 응답으로 보내야 할 때 멀티 상태 정보를 포함해 반환합니다.",
    "solve": "클라이언트는 각 서브리소스 상태(XML 멀티파트 형식 등)를 파싱해 개별적으로 처리합니다."
  },
  {
    "title": "208",
    "reason": "WebDAV 확장으로, 이미 이전에 멀티 상태 응답에 포함된 컬렉션 리소스가 다시 보고되지 않도록 합니다.",
    "solve": "클라이언트는 중복 처리를 피하고 첫 보고된 정보만 사용합니다."
  },
  {
    "title": "226",
    "reason": "RFC 3229 확장 코드로, 클라이언트가 Delta-encoding 요청을 통해 리소스의 변경분만 요청했으며, 서버가 IM(Instance Manipulations)로 처리해 반환했음을 나타냅니다.",
    "solve": "클라이언트는 반환된 delta를 기존 리소스에 적용해 최신 상태를 갱신합니다."
  },
  {
    "title": "300",
    "reason": "서버가 요청한 리소스에 대해 여러 대안을 제공할 때 사용합니다. 클라이언트는 사용 가능한 옵션을 선택해야 합니다.",
    "solve": "클라이언트는 응답의 Link 헤더나 본문 표기를 보고 원하는 리소스를 선택해 재요청합니다."
  },
  {
    "title": "301",
    "reason": "요청한 리소스가 영구적으로 다른 URI로 이동했음을 나타냅니다. 이후 요청은 새 URI로 보내야 합니다.",
    "solve": "클라이언트는 Location 헤더의 새 URI로 요청을 다시 보내거나, 저장해 둘 경우 북마크를 업데이트합니다."
  },
  {
    "title": "302",
    "reason": "요청한 리소스가 일시적으로 다른 URI에 있음을 나타냅니다. 이후에도 원 URI를 계속 사용할 수 있습니다.",
    "solve": "클라이언트는 Location 헤더를 따라가지만, 다음 요청은 원래 URI로 보내야 합니다."
  },
  {
    "title": "303",
    "reason": "요청 처리 결과를 다른 URI에서 확인하도록 리다이렉트할 때 사용합니다. 주로 POST 후 GET으로 전환할 때 활용됩니다.",
    "solve": "클라이언트는 Location 헤더의 URI로 GET 요청을 보내 결과를 조회합니다."
  },
  {
    "title": "304",
    "reason": "클라이언트가 If-Modified-Since 또는 If-None-Match 조건부 요청을 했고, 리소스가 변경되지 않아 새 본문을 전송할 필요가 없을 때 사용합니다.",
    "solve": "클라이언트는 로컬 캐시된 리소스를 그대로 사용합니다."
  },
  {
    "title": "305",
    "reason": "요청한 리소스에 접근하기 위해 반드시 프록시를 사용해야 함을 나타냅니다. 보안상의 이유로 현재는 거의 사용되지 않습니다.",
    "solve": "클라이언트는 Location 헤더의 프록시 서버를 통해 재전송할 수 있지만, 최신 브라우저에서는 지원되지 않을 수 있습니다."
  },
  {
    "title": "307",
    "reason": "302와 비슷하나, HTTP 메서드가 변경되지 않아야 함을 보장합니다. 임시 리다이렉션으로, POST를 POST로 유지합니다.",
    "solve": "클라이언트는 Location 헤더를 따라가되, 원래 메서드와 본문을 그대로 유지합니다."
  },
  {
    "title": "308",
    "reason": "301과 비슷하나, HTTP 메서드가 변경되지 않아야 함을 보장합니다. 영구 리다이렉션으로, POST를 POST로 유지합니다.",
    "solve": "클라이언트는 Location 헤더의 새 URI로, 원래 메서드와 본문을 그대로 전송합니다."
  }
]

